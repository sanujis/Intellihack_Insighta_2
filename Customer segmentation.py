# -*- coding: utf-8 -*-
"""Clustering

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/clustering-7d0b6c21-65bd-4550-b320-6b016ea287a0.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20250309/auto/storage/goog4_request%26X-Goog-Date%3D20250309T081342Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3Dd269d8a94d377b4b0c6f24ff2bd9f022722d46fc014ef8b416152084f4021ad0c1d84ba2bea3d12838a028605a1587b0f4e953bcaacacd95d3f181724a06250facb728ece80a22e7dddd5136a8b611b1a05fc68409ce03d42c318df5052089d4436d3f48682d48e3fe9f902a226f5d2300fcb3f64b64fa9eb2aaaba7e9a9b1768672bd53ae5166bc0ebe226af48733c817bc9797466cafa6016120f5b1d36c709c7d10cfe2aeebe0d7210905e1616da15c46ef1075b547fd4940d4d18d29fec0300efb51335311541504dfceea251e0a2b8285dcf65a51355eda6f53b85a0da02c531374d8fe55e8c83151a93232e456cf68e18be15111a14bfa5266c35147b0
"""

import numpy as np
import pandas as pd

dataset_path = "/content/customer_behavior_analytcis.csv"

df = pd.read_csv(dataset_path)

df

df.isnull().sum()

df["total_purchases"] = df["total_purchases"].fillna(df["total_purchases"].median())
df["avg_cart_value"] = df["avg_cart_value"].fillna(df["avg_cart_value"].median())
df["product_click"] = df["product_click"].fillna(df["product_click"].median())

from scipy.stats import zscore

z_scores = zscore(df[['total_purchases', 'avg_cart_value', 'product_click','total_time_spent','discount_counts']])

abs_z_scores = np.abs(z_scores)
outliers = (abs_z_scores > 3)

df = df[~outliers.any(axis=1)]

df.shape

df = df.drop(columns=['customer_id'])

df.corr()

# df = df.drop(columns=['total_time_spent','discount_counts'])

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()
df_scaled = scaler.fit_transform(df)

# from sklearn.preprocessing import StandardScaler

# scaler = StandardScaler()
# df_scaled = scaler.fit_transform(df)

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.layers import Input, Dense
from tensorflow.keras.models import Model
import random

# Define the autoencoder
input_dim = df_scaled.shape[1]
encoding_dim = 4

input_layer = Input(shape=(input_dim,))
encoded = Dense(encoding_dim, activation='relu')(input_layer)
decoded = Dense(input_dim, activation='linear')(encoded)

autoencoder = Model(input_layer, decoded)
encoder = Model(input_layer, encoded)

# Compile and train
autoencoder.compile(optimizer='adam', loss='mse')
autoencoder.fit(df_scaled, df_scaled, epochs=50, batch_size=16, shuffle=True)


# Get the compressed features
df_encoded = encoder.predict(df_scaled)

# from sklearn.cluster import KMeans

# kmeans = KMeans(n_clusters=3, max_iter=1000, n_init=10)
# df["cluster"] = kmeans.fit_predict(df_encoded)

# cluster_centers = pd.DataFrame(scaler.inverse_transform(kmeans.cluster_centers_), columns=df.columns[:-1])
# print("Cluster Centers:\n", cluster_centers)

# cluster_mapping = {
#     np.argmax(cluster_centers['total_purchases']): 'Bargain Hunters',
#     np.argmax(cluster_centers['avg_cart_value']): 'High Spenders',
#     np.argmax(cluster_centers['product_click']): 'Window Shoppers'
# }

# df['segment'] = df['cluster'].map(cluster_mapping)

from sklearn.mixture import GaussianMixture

gmm = GaussianMixture(n_components=3,random_state=42 ,covariance_type='full', init_params='kmeans', max_iter=1000)
df['cluster'] = gmm.fit_predict(df_encoded)

# from sklearn.cluster import AgglomerativeClustering

# agg_clust = AgglomerativeClustering(n_clusters=3)
# df['cluster'] = agg_clust.fit_predict(df_scaled)

cluster_means = df.groupby("cluster").mean()
cluster_means

cluster_mapping = {}

max_total_purchases_cluster = df.groupby('cluster')['total_purchases'].max().idxmax()
cluster_mapping[max_total_purchases_cluster] = "Bargain Hunters"

max_avg_cart_value_cluster = df.groupby('cluster')['avg_cart_value'].max().idxmax()
cluster_mapping[max_avg_cart_value_cluster] = "High Spenders"

remaining_cluster = set(df['cluster'].unique()) - set(cluster_mapping.keys())
cluster_mapping[remaining_cluster.pop()] = "Window Shoppers"

df['segment'] = df['cluster'].map(cluster_mapping)

# from sklearn.cluster import DBSCAN

# best_eps = 4  # Adjust this value
# best_min_samples = 3  # Adjust this value

# # Apply DBSCAN
# dbscan = DBSCAN(eps=best_eps, min_samples=best_min_samples)
# df['cluster'] = dbscan.fit_predict(df_scaled)

# from sklearn.cluster import DBSCAN

# # Try different combinations of `eps` and `min_samples`
# eps_values = np.arange(0.5, 10.0, 0.5)  # Range of eps values
# min_samples_values = [3, 4, 5, 6]  # Different min_samples values

# # Loop through combinations and check cluster counts
# for eps in eps_values:
#     for min_samples in min_samples_values:
#         dbscan = DBSCAN(eps=eps, min_samples=min_samples)
#         df['cluster'] = dbscan.fit_predict(df_scaled)  # Assuming df_scaled is your normalized data

#         # Count the number of clusters excluding noise (-1)
#         num_clusters = len(set(df['cluster'])) - (1 if -1 in df['cluster'].values else 0)

#         if num_clusters == 3:
#             print(f"Found 3 clusters with eps={eps} and min_samples={min_samples}")

df = df.drop(columns=['cluster'])

import matplotlib.pyplot as plt
import seaborn as sns

sns.pairplot(df, hue='segment', palette="Set1")
plt.show()

from sklearn.metrics import silhouette_score

score = silhouette_score(df_encoded, df['segment'])
print(f"Silhouette Score: {score}")

from sklearn.metrics import davies_bouldin_score

features = df.drop(columns=['segment'])
labels = df['segment']

dbi_score = davies_bouldin_score(features, labels)
print(f"Davies-Bouldin Index: {dbi_score}")